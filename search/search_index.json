{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"rich-codex \u26a1\ufe0f\ud83d\udcd6\u26a1\ufe0f A GitHub Action / command-line tool which generates screengrab images of a terminal window, containing command outputs or code snippets . Introduction Having code examples in your documentation is a fantastic way to help users understand what to expect from your tool. Using terminal screenshots is a good way to do this because: \ud83c\udf08 Coloured terminal output is supported \u2194\ufe0f You can fit in long lines without scrolling or cropping (images are auto-resized) \ud83d\ude0e They look cool However, manually generating these screenshots is a pain \ud83d\udc4e\ud83c\udffb Remembering to update them every time you make a minor change means that they can easily get out of date. Rich-codex automates this process for you. It searches markdown code for images with shell commands or code snippets. It runs these commands and saves a terminal screen-grab at the embedded path. Typical use cases: \ud83d\udcf7 Example CLI tool outputs that automatically stay in sync with your package \u267b\ufe0f Syntax-highlighted code snippets that are always up to date with your examples/ \ud83e\udd29 Fast and simple images for your docs with minimal setup Quickstart \ud83d\udcd6 Write some markdown docs, use an image tag with a backtick command inside: ![ `cat cat.txt | lolcat -S 1` ]( img/cat.svg ) 2. \ud83e\udd16 Add a GitHub Action to automatically run the command, generate the image and commit to the repo: on : [ push ] jobs : rich_codex : runs-on : ubuntu-latest steps : - uses : actions/checkout@v3 - name : Install your custom tools run : pip install lolcat - name : Generate terminal images with rich-codex uses : ewels/rich-codex@v1 with : commit_changes : \"true\" \ud83c\udf08 Enjoy reading your documentation How it works Rich-codex is a command-line tool that you can run via a GitHub action or as a command line tool . It works with any markdown (including GitHub READMEs). It collects either commands or code snippets, together with output filenames and configuration options. Commands are run in a subprocess and the standard output & standard error collected. These are then rendered as an image using Textualize/rich . Tip Rich-codex creates the images that your markdown docs expect. It doesn't require a HTML build-step and doesn't make any changes to your markdown or its output. As such, it's compatible with any documentation engine , including rendering markdown on github.com . Rich-codex needs inputs (commands / snippets) and output filenames to work. These can be configured in four different ways: \ud83d\uddbc Markdown images Search markdown files for image tags with command alt text. eg: ![`rich-codex --help`](img/rich-codex-help.svg) \ud83d\udcac Markdown comments Search markdown files for special HTML comments. \u27a1\ufe0f Command-line / action inputs Specify a command or snippet using the action with inputs. \u2699\ufe0f Config files Use one or more YAML config files for multiple images and more complex customisation. Images can be generated as SVG, PNG or PDF (detected by filename extension).","title":"Home"},{"location":"#rich-codex","text":"A GitHub Action / command-line tool which generates screengrab images of a terminal window, containing command outputs or code snippets .","title":"rich-codex \u26a1\ufe0f\ud83d\udcd6\u26a1\ufe0f"},{"location":"#introduction","text":"Having code examples in your documentation is a fantastic way to help users understand what to expect from your tool. Using terminal screenshots is a good way to do this because: \ud83c\udf08 Coloured terminal output is supported \u2194\ufe0f You can fit in long lines without scrolling or cropping (images are auto-resized) \ud83d\ude0e They look cool However, manually generating these screenshots is a pain \ud83d\udc4e\ud83c\udffb Remembering to update them every time you make a minor change means that they can easily get out of date. Rich-codex automates this process for you. It searches markdown code for images with shell commands or code snippets. It runs these commands and saves a terminal screen-grab at the embedded path. Typical use cases: \ud83d\udcf7 Example CLI tool outputs that automatically stay in sync with your package \u267b\ufe0f Syntax-highlighted code snippets that are always up to date with your examples/ \ud83e\udd29 Fast and simple images for your docs with minimal setup","title":"Introduction"},{"location":"#quickstart","text":"\ud83d\udcd6 Write some markdown docs, use an image tag with a backtick command inside: ![ `cat cat.txt | lolcat -S 1` ]( img/cat.svg ) 2. \ud83e\udd16 Add a GitHub Action to automatically run the command, generate the image and commit to the repo: on : [ push ] jobs : rich_codex : runs-on : ubuntu-latest steps : - uses : actions/checkout@v3 - name : Install your custom tools run : pip install lolcat - name : Generate terminal images with rich-codex uses : ewels/rich-codex@v1 with : commit_changes : \"true\" \ud83c\udf08 Enjoy reading your documentation","title":"Quickstart"},{"location":"#how-it-works","text":"Rich-codex is a command-line tool that you can run via a GitHub action or as a command line tool . It works with any markdown (including GitHub READMEs). It collects either commands or code snippets, together with output filenames and configuration options. Commands are run in a subprocess and the standard output & standard error collected. These are then rendered as an image using Textualize/rich . Tip Rich-codex creates the images that your markdown docs expect. It doesn't require a HTML build-step and doesn't make any changes to your markdown or its output. As such, it's compatible with any documentation engine , including rendering markdown on github.com . Rich-codex needs inputs (commands / snippets) and output filenames to work. These can be configured in four different ways: \ud83d\uddbc Markdown images Search markdown files for image tags with command alt text. eg: ![`rich-codex --help`](img/rich-codex-help.svg) \ud83d\udcac Markdown comments Search markdown files for special HTML comments. \u27a1\ufe0f Command-line / action inputs Specify a command or snippet using the action with inputs. \u2699\ufe0f Config files Use one or more YAML config files for multiple images and more complex customisation. Images can be generated as SVG, PNG or PDF (detected by filename extension).","title":"How it works"},{"location":"safety/","text":"\ud83d\udca5\u26a0\ufe0f Warning \u26a0\ufe0f\ud83d\udca5 Reminder: rich-codex runs arbitrary commands found in documentation on your host system. You are responsible for ensuring that it does not do any damage. Prompts for commands When rich-codex runs interactively, it collects all commands to be run and presents these to you, the user. You then need to choose whether to run all commands, choose some or to ignore all of them. You can disable these checks by using the --no-confirm CLI flag / setting env var $NO_CONFIRM . Banned commands As a very basic safety step, rich-codex attempts to ignore any commands that start with the following: rm , cp , mv , sudo . This is to avoid accidentally messing with your local system. Please note that this is only for rough protection against accidents and would be easy for a malicious user to circumvent (for example, putting these commands in a bash script and running that) . Git checks By default, rich-codex checks that: You are running within a initialised git repository You do not have any uncommitted changes This is because rich-codex overwrites local files. If you're running within a clean git repo you can easily see what has been changed and revert it. You can disable these checks by using the --skip-git-checks CLI flag / setting env var $SKIP_GIT_CHECKS .","title":"Safety"},{"location":"safety/#prompts-for-commands","text":"When rich-codex runs interactively, it collects all commands to be run and presents these to you, the user. You then need to choose whether to run all commands, choose some or to ignore all of them. You can disable these checks by using the --no-confirm CLI flag / setting env var $NO_CONFIRM .","title":"Prompts for commands"},{"location":"safety/#banned-commands","text":"As a very basic safety step, rich-codex attempts to ignore any commands that start with the following: rm , cp , mv , sudo . This is to avoid accidentally messing with your local system. Please note that this is only for rough protection against accidents and would be easy for a malicious user to circumvent (for example, putting these commands in a bash script and running that) .","title":"Banned commands"},{"location":"safety/#git-checks","text":"By default, rich-codex checks that: You are running within a initialised git repository You do not have any uncommitted changes This is because rich-codex overwrites local files. If you're running within a clean git repo you can easily see what has been changed and revert it. You can disable these checks by using the --skip-git-checks CLI flag / setting env var $SKIP_GIT_CHECKS .","title":"Git checks"},{"location":"troubleshooting/","text":"No image generated First up: did you remember the ! ? It's ![`command`](path) - I've spent longer than I'd care to admit debugging only to realise I missed the leading ! \ud83d\ude48 Next, check the verbose log - it's saved as an artefact with GitHub Actions or locally you can use the -v / --verbose flag. The verbose log tells you which files are being searched and gives you more insight into what rich-codex is doing. Can't push new commits If you're fairly new to using git, you might find this error message a bit intimidating when you first see it: Fear not, what has likely happened is: Your rich-codex GitHub Action has run since you last pushed It created some new images and you have set it to automatically commit these new images to your repository Because of this, your git remote now has new commits that you don't yet have locally Git doesn't let you push your work until that's resolved The fix is usually simple - you need to pull the new commits and tell git to rebase your new work on top of that. Git will shuffle the commits one in front of the other and then you'll be able to push without any issues:","title":"Troubleshooting"},{"location":"troubleshooting/#no-image-generated","text":"First up: did you remember the ! ? It's ![`command`](path) - I've spent longer than I'd care to admit debugging only to realise I missed the leading ! \ud83d\ude48 Next, check the verbose log - it's saved as an artefact with GitHub Actions or locally you can use the -v / --verbose flag. The verbose log tells you which files are being searched and gives you more insight into what rich-codex is doing.","title":"No image generated"},{"location":"troubleshooting/#cant-push-new-commits","text":"If you're fairly new to using git, you might find this error message a bit intimidating when you first see it: Fear not, what has likely happened is: Your rich-codex GitHub Action has run since you last pushed It created some new images and you have set it to automatically commit these new images to your repository Because of this, your git remote now has new commits that you don't yet have locally Git doesn't let you push your work until that's resolved The fix is usually simple - you need to pull the new commits and tell git to rebase your new work on top of that. Git will shuffle the commits one in front of the other and then you'll be able to push without any issues:","title":"Can't push new commits"},{"location":"config/cleaning/","text":"Removing images If you change the output filename of an image, a new file will be created. However, the old one will remain which is probably not what you intended. To avoid this rich-codex can \"clean\" an image path, deleting any matching files that were not generated during a run. This is done using --clean-img-paths / $CLEAN_IMG_PATHS / clean_img_paths (CLI, env var, action/config). One or more filename glob patterns (separated by newlines) can be given. At the end of the run, all matching files that were not generated will be deleted. Warning Rich-codex will clean all files matching your pattern. Including your source code. Handle with care \ud83d\udd25","title":"Removing images"},{"location":"config/cleaning/#removing-images","text":"If you change the output filename of an image, a new file will be created. However, the old one will remain which is probably not what you intended. To avoid this rich-codex can \"clean\" an image path, deleting any matching files that were not generated during a run. This is done using --clean-img-paths / $CLEAN_IMG_PATHS / clean_img_paths (CLI, env var, action/config). One or more filename glob patterns (separated by newlines) can be given. At the end of the run, all matching files that were not generated will be deleted. Warning Rich-codex will clean all files matching your pattern. Including your source code. Handle with care \ud83d\udd25","title":"Removing images"},{"location":"config/colours/","text":"Using a pseudo-terminal By default, rich-codex runs commands in a Python subprocess . This is not an interactive termainal, and as such many command-line tools will disable coloured output. This is best solved at the tool level if possible, by telling the tool to force coloured output. However, if this is not possible then you can use --use-pty / $USE_PTY / use_pty (CLI, env var, action/config). This uses a Python pty pseudo-terminal instead of subprocess which may trick your tool into keeping coloured output. Warning Note that PTY almost certainly won't work on Windows and is generally more likely to do weird stuff / create poorly formatted outputs than the default subprocess shell. Colour theme You can customise the theme using --terminal-theme / $TERMINAL_THEME / terminal_theme (CLI, env, action/config). Themes are taken from Rich , at the time of writing the following are available: DEFAULT_TERMINAL_THEME MONOKAI DIMMED_MONOKAI NIGHT_OWLISH SVG_EXPORT_THEME The terminal theme should be set as a string to one of these values. Note It's planned to add support for custom themes but not yet implemented. If you need this, please create a GitHub issue / pull-request. DEFAULT_TERMINAL_THEME : MONOKAI : DIMMED_MONOKAI : NIGHT_OWLISH : SVG_EXPORT_THEME : Snippet colours Snippets are formatted using rich Syntax objects . These use Pygments to add code colouring, which has its own set of themes - separate to the terminal theme that the snippet is wrapped in. As such, if using snippets, you'll probably want to set both the terminal theme and the Pygments style. You can find available Pygments styles in the Pygments docs . snippet_theme: xcode + terminal_theme: DEFAULT_TERMINAL_THEME : snippet_theme: monokai + terminal_theme: SVG_EXPORT_THEME : snippet_theme: fruity + terminal_theme: MONOKAI :","title":"Colours"},{"location":"config/colours/#using-a-pseudo-terminal","text":"By default, rich-codex runs commands in a Python subprocess . This is not an interactive termainal, and as such many command-line tools will disable coloured output. This is best solved at the tool level if possible, by telling the tool to force coloured output. However, if this is not possible then you can use --use-pty / $USE_PTY / use_pty (CLI, env var, action/config). This uses a Python pty pseudo-terminal instead of subprocess which may trick your tool into keeping coloured output. Warning Note that PTY almost certainly won't work on Windows and is generally more likely to do weird stuff / create poorly formatted outputs than the default subprocess shell.","title":"Using a pseudo-terminal"},{"location":"config/colours/#colour-theme","text":"You can customise the theme using --terminal-theme / $TERMINAL_THEME / terminal_theme (CLI, env, action/config). Themes are taken from Rich , at the time of writing the following are available: DEFAULT_TERMINAL_THEME MONOKAI DIMMED_MONOKAI NIGHT_OWLISH SVG_EXPORT_THEME The terminal theme should be set as a string to one of these values. Note It's planned to add support for custom themes but not yet implemented. If you need this, please create a GitHub issue / pull-request. DEFAULT_TERMINAL_THEME : MONOKAI : DIMMED_MONOKAI : NIGHT_OWLISH : SVG_EXPORT_THEME :","title":"Colour theme"},{"location":"config/colours/#snippet-colours","text":"Snippets are formatted using rich Syntax objects . These use Pygments to add code colouring, which has its own set of themes - separate to the terminal theme that the snippet is wrapped in. As such, if using snippets, you'll probably want to set both the terminal theme and the Pygments style. You can find available Pygments styles in the Pygments docs . snippet_theme: xcode + terminal_theme: DEFAULT_TERMINAL_THEME : snippet_theme: monokai + terminal_theme: SVG_EXPORT_THEME : snippet_theme: fruity + terminal_theme: MONOKAI :","title":"Snippet colours"},{"location":"config/command_setup/","text":"Setting extra environment vars In some cases you may want to set environment variables for a single command only. In this case, you can use the extra_env config option, which adds YAML key:value pairs to the environment for just that command (and the before / after commands, see below). I use this method to set the terminal width for the rich-codex screenshots in this documentation: <!-- RICH-CODEX terminal_width: 120 notrim: true extra_env: TERMINAL_WIDTH: 120 --> ![ `rich-codex --help` ]( ../img/rich-codex-cli-envs.svg ) Tip It's probably easier to set these at run-level if that's an option, these are really only if you want to customise for a single output. Faking simple commands Sometimes you may need to have long complicated commands to get the screenshot you need, when the typical command for an end user would be much simpler. In this case, you can fake the command shown in the terminal prompt using --fake-command / $FAKE_COMMAND / fake_command . For example: <!-- RICH-CODEX fake_command: \"my_tool --is-simple\" --> ![ `echo \"I won't tell if you don't \ud83e\udd2b\" > temp_file.txt && echo \"\" && cat temp_file.txt && rm temp_file.txt` ]( ../img/fake_command.svg ) Running commands before and after Chaining complex commands may not always work if the setup / cleanup commands generate output that you don't want to show in the screenshot. In these more complex scenarios, you can run additional commands before and after the one used for the screenshot. This is done with the following options: --before-command / $BEFORE_COMMAND / before_command --after-command / $AFTER_COMMAND / after_command . These run separate subprocess calls with the specified commands before and after the target command. This can be useful for initialising an environment and then cleaning up afterwards. For example: <!-- RICH-CODEX before_command: > echo \"This is a very simple example\" > before_after_command_example.txt after_command: rm before_after_command_example.txt --> ![ `cat before_after_command_example.txt` ]( ../img/before_after_command.svg ) !!! note: Commands should be a single string, so remember to chain using && and ideally use YAML multi-line strings that collapse newlines using > .","title":"Command setup"},{"location":"config/command_setup/#setting-extra-environment-vars","text":"In some cases you may want to set environment variables for a single command only. In this case, you can use the extra_env config option, which adds YAML key:value pairs to the environment for just that command (and the before / after commands, see below). I use this method to set the terminal width for the rich-codex screenshots in this documentation: <!-- RICH-CODEX terminal_width: 120 notrim: true extra_env: TERMINAL_WIDTH: 120 --> ![ `rich-codex --help` ]( ../img/rich-codex-cli-envs.svg ) Tip It's probably easier to set these at run-level if that's an option, these are really only if you want to customise for a single output.","title":"Setting extra environment vars"},{"location":"config/command_setup/#faking-simple-commands","text":"Sometimes you may need to have long complicated commands to get the screenshot you need, when the typical command for an end user would be much simpler. In this case, you can fake the command shown in the terminal prompt using --fake-command / $FAKE_COMMAND / fake_command . For example: <!-- RICH-CODEX fake_command: \"my_tool --is-simple\" --> ![ `echo \"I won't tell if you don't \ud83e\udd2b\" > temp_file.txt && echo \"\" && cat temp_file.txt && rm temp_file.txt` ]( ../img/fake_command.svg )","title":"Faking simple commands"},{"location":"config/command_setup/#running-commands-before-and-after","text":"Chaining complex commands may not always work if the setup / cleanup commands generate output that you don't want to show in the screenshot. In these more complex scenarios, you can run additional commands before and after the one used for the screenshot. This is done with the following options: --before-command / $BEFORE_COMMAND / before_command --after-command / $AFTER_COMMAND / after_command . These run separate subprocess calls with the specified commands before and after the target command. This can be useful for initialising an environment and then cleaning up afterwards. For example: <!-- RICH-CODEX before_command: > echo \"This is a very simple example\" > before_after_command_example.txt after_command: rm before_after_command_example.txt --> ![ `cat before_after_command_example.txt` ]( ../img/before_after_command.svg ) !!! note: Commands should be a single string, so remember to chain using && and ideally use YAML multi-line strings that collapse newlines using > .","title":"Running commands before and after"},{"location":"config/ignoring_changes/","text":"You may find that your screenshots are changing every time you run rich-codex, even though no relevant changes have occured within your code. This could be because the screenshots include timestamps or some other live data. To avoid doubling your commit count with changes that you don't care about, rich-codex has two mechanisms which you can use to ignore changes: \u2696\ufe0f Percentage change in file contents \ud83d\udd0e Regular expression matches Percentage change in file contents When you run rich-codex, any new images created will generate log messages that look like this: Saved: 'docs/img/rich-codex-snippet-title.svg' (4.63% change) . This percentage change is calculated using the python-Levenshtein package, comparing the raw bytes of the two files. By default, any new files with 0.00% change will be ignored. If you find that you have screenshots changing by the same small percentage every time, you can raise this threshold by setting --min-pct-diff / $MIN_PCT_DIFF / min_pct_diff (CLI, env var, action/config). For example, if a timestamp caused this file to change by 4.34% on every commit, those changes could be ignored as follows: <!-- RICH-CODEX min_pct_diff: 5 --> ![ `rich-codex --help` ]( ../img/rich-codex-help-min-pct.svg ) Regular expression matches Percentage changes in files is quick and simple, but a little crude. If you prefer, you may be able to use regular expressions instead with --skip-change-regex / $SKIP_CHANGE_REGEX / skip_change_regex (CLI, env var, action/config). If there is a > 0% change in files, a rich diff will be generated. Any diff lines matching the supplied regexes will be removed and if none remain, the changeset will be ignored. Rich-codex ships with one default, applied for PDF files: if the only change is a line with \"/CreationDate\" then the changeset will be ignored. Warning Please note that generating diffs between file pairs can be very slow. Use with caution.","title":"Ignoring changes"},{"location":"config/ignoring_changes/#percentage-change-in-file-contents","text":"When you run rich-codex, any new images created will generate log messages that look like this: Saved: 'docs/img/rich-codex-snippet-title.svg' (4.63% change) . This percentage change is calculated using the python-Levenshtein package, comparing the raw bytes of the two files. By default, any new files with 0.00% change will be ignored. If you find that you have screenshots changing by the same small percentage every time, you can raise this threshold by setting --min-pct-diff / $MIN_PCT_DIFF / min_pct_diff (CLI, env var, action/config). For example, if a timestamp caused this file to change by 4.34% on every commit, those changes could be ignored as follows: <!-- RICH-CODEX min_pct_diff: 5 --> ![ `rich-codex --help` ]( ../img/rich-codex-help-min-pct.svg )","title":"Percentage change in file contents"},{"location":"config/ignoring_changes/#regular-expression-matches","text":"Percentage changes in files is quick and simple, but a little crude. If you prefer, you may be able to use regular expressions instead with --skip-change-regex / $SKIP_CHANGE_REGEX / skip_change_regex (CLI, env var, action/config). If there is a > 0% change in files, a rich diff will be generated. Any diff lines matching the supplied regexes will be removed and if none remain, the changeset will be ignored. Rich-codex ships with one default, applied for PDF files: if the only change is a line with \"/CreationDate\" then the changeset will be ignored. Warning Please note that generating diffs between file pairs can be very slow. Use with caution.","title":"Regular expression matches"},{"location":"config/overview/","text":"Config locations Rich-codex can be run in several different ways and get configuration from multiple different locations. They are, in order of parsing / precidence (last location wins): Global, for entire run: GitHub Action arguments Environment variables Command-line flags (CLI) Rich-codex config files Per-image: Rich-codex config files Markdown config Overview of all options An overview of all available config options in all scopes is below: CLI Environment variable GitHub Action / Rich-codex config --search-include SEARCH_INCLUDE search_include --search-exclude SEARCH_EXCLUDE search_exclude --no-search NO_SEARCH no_search --command COMMAND command --timeout TIMEOUT timeout --snippet SNIPPET snippet --snippet-syntax SNIPPET_SYNTAX snippet_syntax --img-paths IMG_PATHS img_paths --clean-img-paths CLEAN_IMG_PATHS clean_img_paths --configs RC_CONFIGS rc_configs --hide-command HIDE_COMMAND hide_command --title-command TITLE_COMMAND title_command --head RC_HEAD head --tail RC_TAIL tail --trim-after TRIM_AFTER trim_after --truncated-text TRUNCATED_TEXT truncated_text --skip-git-checks SKIP_GIT_CHECKS skip_git_checks --no-confirm NO_CONFIRM - --min-pct-diff MIN_PCT_DIFF min_pct_diff --skip-change-regex SKIP_CHANGE_REGEX skip_change_regex --terminal-width TERMINAL_WIDTH terminal_width --terminal-min-width TERMINAL_MIN_WIDTH terminal_min_width --notrim NOTRIM notrim --terminal-theme TERMINAL_THEME terminal_theme --snippet-theme SNIPPET_THEME snippet_theme --use-pty USE_PTY use_pty --created-files CREATED_FILES - --deleted-files DELETED_FILES - --verbose LOG_VERBOSE log_verbose * --save-log LOG_SAVE - --log-file LOG_FILENAME - - - commit_changes * - - error_changes * - - title \u2020 - - extra_env \u2020 - - skip \u2020 * - GitHub Action only \u2020 - Markdown / config only (per-output, not global) Description of options A brief description of each option follows. Note Hopefully all config options will be either fairly self-explanitory and/or documented in more details elsewhere. If not, please open an issue on GitHub --search-include : Glob patterns to search for rich-codex comments --search-exclude : Glob patterns to exclude from search for rich-codex comments --no-search : Set to disable searching for rich-codex comments --command : Specify a command to run to capture output --timeout : Maximum run time for command (seconds) --hide-command : Hide the terminal prompt with the command at the top of the output --title-command : Use the command as the terminal title if not set explicitly --head : Show only the first N lines of output --tail : Show only the last N lines of output --trim-after : Don't print any more lines after this string is found --truncated-text : Text to show when --head or --tail truncate content --snippet : Literal code snippet to render --snippet-syntax : Language to use for snippet sytax highlighting --img-paths : Path to image filenames if using 'command' or 'snippet' --clean-img-paths : Remove any matching files that are not generated --configs : Paths to YAML config files --skip-git-checks : Skip safety checks for git repos --no-confirm : Set to skip confirmation prompt before running commands --min-pct-diff : Minimum file percentage change required to update image --skip-change-regex : Skip image update if file changes match regex --terminal-width : Width of the terminal --terminal-min-width : Minimum width of the terminal when trimming --notrim : Disable automatic trimming of terminal width --terminal-theme : Colour theme --snippet-theme : Snippet Pygments theme --use-pty : Use a pseudo-terminal for commands (may capture coloured output) --created-files : Save a list of created files to this file --deleted-files : Save a list of deleted files to this file --verbose : Print verbose output to the console. --save-log : Save a verbose log to a file (automatic filename). --log-file : Save a verbose log to a file (specific filename). commit_changes : Automatically commit changes to the repository error_changes : Exit with an error if changes are found (Ignored if commit_changes is true) title : Title for the terminal title bar skip : Skip / ignore this image","title":"Overview"},{"location":"config/overview/#config-locations","text":"Rich-codex can be run in several different ways and get configuration from multiple different locations. They are, in order of parsing / precidence (last location wins): Global, for entire run: GitHub Action arguments Environment variables Command-line flags (CLI) Rich-codex config files Per-image: Rich-codex config files Markdown config","title":"Config locations"},{"location":"config/overview/#overview-of-all-options","text":"An overview of all available config options in all scopes is below: CLI Environment variable GitHub Action / Rich-codex config --search-include SEARCH_INCLUDE search_include --search-exclude SEARCH_EXCLUDE search_exclude --no-search NO_SEARCH no_search --command COMMAND command --timeout TIMEOUT timeout --snippet SNIPPET snippet --snippet-syntax SNIPPET_SYNTAX snippet_syntax --img-paths IMG_PATHS img_paths --clean-img-paths CLEAN_IMG_PATHS clean_img_paths --configs RC_CONFIGS rc_configs --hide-command HIDE_COMMAND hide_command --title-command TITLE_COMMAND title_command --head RC_HEAD head --tail RC_TAIL tail --trim-after TRIM_AFTER trim_after --truncated-text TRUNCATED_TEXT truncated_text --skip-git-checks SKIP_GIT_CHECKS skip_git_checks --no-confirm NO_CONFIRM - --min-pct-diff MIN_PCT_DIFF min_pct_diff --skip-change-regex SKIP_CHANGE_REGEX skip_change_regex --terminal-width TERMINAL_WIDTH terminal_width --terminal-min-width TERMINAL_MIN_WIDTH terminal_min_width --notrim NOTRIM notrim --terminal-theme TERMINAL_THEME terminal_theme --snippet-theme SNIPPET_THEME snippet_theme --use-pty USE_PTY use_pty --created-files CREATED_FILES - --deleted-files DELETED_FILES - --verbose LOG_VERBOSE log_verbose * --save-log LOG_SAVE - --log-file LOG_FILENAME - - - commit_changes * - - error_changes * - - title \u2020 - - extra_env \u2020 - - skip \u2020 * - GitHub Action only \u2020 - Markdown / config only (per-output, not global)","title":"Overview of all options"},{"location":"config/overview/#description-of-options","text":"A brief description of each option follows. Note Hopefully all config options will be either fairly self-explanitory and/or documented in more details elsewhere. If not, please open an issue on GitHub --search-include : Glob patterns to search for rich-codex comments --search-exclude : Glob patterns to exclude from search for rich-codex comments --no-search : Set to disable searching for rich-codex comments --command : Specify a command to run to capture output --timeout : Maximum run time for command (seconds) --hide-command : Hide the terminal prompt with the command at the top of the output --title-command : Use the command as the terminal title if not set explicitly --head : Show only the first N lines of output --tail : Show only the last N lines of output --trim-after : Don't print any more lines after this string is found --truncated-text : Text to show when --head or --tail truncate content --snippet : Literal code snippet to render --snippet-syntax : Language to use for snippet sytax highlighting --img-paths : Path to image filenames if using 'command' or 'snippet' --clean-img-paths : Remove any matching files that are not generated --configs : Paths to YAML config files --skip-git-checks : Skip safety checks for git repos --no-confirm : Set to skip confirmation prompt before running commands --min-pct-diff : Minimum file percentage change required to update image --skip-change-regex : Skip image update if file changes match regex --terminal-width : Width of the terminal --terminal-min-width : Minimum width of the terminal when trimming --notrim : Disable automatic trimming of terminal width --terminal-theme : Colour theme --snippet-theme : Snippet Pygments theme --use-pty : Use a pseudo-terminal for commands (may capture coloured output) --created-files : Save a list of created files to this file --deleted-files : Save a list of deleted files to this file --verbose : Print verbose output to the console. --save-log : Save a verbose log to a file (automatic filename). --log-file : Save a verbose log to a file (specific filename). commit_changes : Automatically commit changes to the repository error_changes : Exit with an error if changes are found (Ignored if commit_changes is true) title : Title for the terminal title bar skip : Skip / ignore this image","title":"Description of options"},{"location":"config/time_limits/","text":"As rich-codex runs commands within a non-interactive subshell, any command that requires input could cause the tool to hang forever. To avoid this, rich-codex sets a maximum time limit on all commands (default: 5 seconds ). Once a command runs for this time, it is killed and the screenshot is created with whatever output was captured up to that point. The amount of time that rich-codex waits for can be configured using --timeout / $TIMEOUT / timeout (CLI, env var, action/config).","title":"Time limits"},{"location":"config/tweaks/","text":"Snippet syntax If snippets can be parsed as JSON, they will be automatically reformatted (pretty-printed) and set to use JSON code syntax colouring. Otherwise they will be printed as white text by default. To use coloured syntax highlighting on your non-JSON code snippets, you need to tell rich-codex what syntax to use with the --snippet-syntax / $SNIPPET_SYNTAX / snippet_syntax option (CLI, env var, action/config). Syntax highlighting is done using rich which uses Pygments . Any language supported by Pygments should work. <!-- RICH-CODEX snippet_syntax: \"C++\" snippet: | include <iostream> int main() { std::cout << \"Hello World!\"; return 0; } --> ![ c++ example ]( ../img/snippet-syntax.svg ) Hiding the command By default, rich-codex shows a command prompt with the command that was used to generate the iamge. This can be disabled by setting using --hide-command / $HIDE_COMMAND / hide_command (CLI, env var, action/config). Default: ![ `echo \"See the command printed at the top?\"` ]( ../img/hide-command-default.svg ) With hide_command set to true : ![ `echo \"What command was used? It's a mystery..\"` ]( ../img/hide-command.svg ) Showing the command in the title Rich-codex sets the title in the screenshot only if you provide it (config or as title text in the markdown image). If you like you can tell rich-codex to always use a title, with the command (or fake command) used if the title is not explicitly set. Do this with the --title-command / $TITLE_COMMAND / title_command (CLI, env var, action/config). Default: ![ `echo \"No custom title set\"` ]( ../img/title-command-default.svg ) With title_command set to true : <!-- RICH-CODEX title_command: true --> ![ `echo \"Look ma, a title\"` ]( ../img/title-command.svg ) Truncating content If your tool produces a lot of output you can show just the beginning or end of output. You can set the number of lines of output that you would like to show using: (CLI, env var, action/config) --head / $RC_HEAD / head --tail / $RC_TAIL / tail <!-- RICH-CODEX { head: 10, tail: 8 } --> ![ `rich ../../src/rich_codex/codex_search.py` ]( ../img/head-tail.svg \"codex_search.py\" ) If the number you set is larger than the amount of output then all output will be shown as usual. Tip Remember that you can set both head and tail to remove just the middle section of output \ud83d\ude80 By default, if any output is truncated a line will be printed: [..truncated..] . You can customise this text using --truncated-text / $TRUNCATED_TEXT / truncated_text . Set it to None to omit the line completely. Trimming content You can clean off unwanted content based on a string pattern match using --trim-after / $TRIM_AFTER / trim_after . Set it to a string - if that string is found in the input, no more lines will be printed after that. No truncated_text is shown for this method currently (could be added if anyone wants it). <!-- RICH-CODEX { trim_after: \"class CodexSearch:\", truncated_text: \"Where did the rest of the file go? \ud83d\udd75\ufe0f\u200d\u2640\ufe0f\" } --> ![ `rich ../../src/rich_codex/codex_search.py` ]( ../img/trim-after_truncated-text.svg \"codex_search.py\" )","title":"Tweaks"},{"location":"config/tweaks/#snippet-syntax","text":"If snippets can be parsed as JSON, they will be automatically reformatted (pretty-printed) and set to use JSON code syntax colouring. Otherwise they will be printed as white text by default. To use coloured syntax highlighting on your non-JSON code snippets, you need to tell rich-codex what syntax to use with the --snippet-syntax / $SNIPPET_SYNTAX / snippet_syntax option (CLI, env var, action/config). Syntax highlighting is done using rich which uses Pygments . Any language supported by Pygments should work. <!-- RICH-CODEX snippet_syntax: \"C++\" snippet: | include <iostream> int main() { std::cout << \"Hello World!\"; return 0; } --> ![ c++ example ]( ../img/snippet-syntax.svg )","title":"Snippet syntax"},{"location":"config/tweaks/#hiding-the-command","text":"By default, rich-codex shows a command prompt with the command that was used to generate the iamge. This can be disabled by setting using --hide-command / $HIDE_COMMAND / hide_command (CLI, env var, action/config). Default: ![ `echo \"See the command printed at the top?\"` ]( ../img/hide-command-default.svg ) With hide_command set to true : ![ `echo \"What command was used? It's a mystery..\"` ]( ../img/hide-command.svg )","title":"Hiding the command"},{"location":"config/tweaks/#showing-the-command-in-the-title","text":"Rich-codex sets the title in the screenshot only if you provide it (config or as title text in the markdown image). If you like you can tell rich-codex to always use a title, with the command (or fake command) used if the title is not explicitly set. Do this with the --title-command / $TITLE_COMMAND / title_command (CLI, env var, action/config). Default: ![ `echo \"No custom title set\"` ]( ../img/title-command-default.svg ) With title_command set to true : <!-- RICH-CODEX title_command: true --> ![ `echo \"Look ma, a title\"` ]( ../img/title-command.svg )","title":"Showing the command in the title"},{"location":"config/tweaks/#truncating-content","text":"If your tool produces a lot of output you can show just the beginning or end of output. You can set the number of lines of output that you would like to show using: (CLI, env var, action/config) --head / $RC_HEAD / head --tail / $RC_TAIL / tail <!-- RICH-CODEX { head: 10, tail: 8 } --> ![ `rich ../../src/rich_codex/codex_search.py` ]( ../img/head-tail.svg \"codex_search.py\" ) If the number you set is larger than the amount of output then all output will be shown as usual. Tip Remember that you can set both head and tail to remove just the middle section of output \ud83d\ude80 By default, if any output is truncated a line will be printed: [..truncated..] . You can customise this text using --truncated-text / $TRUNCATED_TEXT / truncated_text . Set it to None to omit the line completely.","title":"Truncating content"},{"location":"config/tweaks/#trimming-content","text":"You can clean off unwanted content based on a string pattern match using --trim-after / $TRIM_AFTER / trim_after . Set it to a string - if that string is found in the input, no more lines will be printed after that. No truncated_text is shown for this method currently (could be added if anyone wants it). <!-- RICH-CODEX { trim_after: \"class CodexSearch:\", truncated_text: \"Where did the rest of the file go? \ud83d\udd75\ufe0f\u200d\u2640\ufe0f\" } --> ![ `rich ../../src/rich_codex/codex_search.py` ]( ../img/trim-after_truncated-text.svg \"codex_search.py\" )","title":"Trimming content"},{"location":"config/width/","text":"Terminal Width Trimming By default, rich-codex will run your command / parse your snippet and check the length of all output lines. The terminal width will be set to that of the longest line. A mimimum width is used to prevent very narrow images. The default for this is 80 characters and can be customised using --terminal-min-width / $TERMINAL_MIN_WIDTH / terminal_min_width (CLI, env var, action/config). To turn off trimming, use --notrim / $NOTRIM / notrim . Info Note that console output that is padded with spaces will use the full terminal width available. Much of the output from the rich library is padded. In these cases, you will need to consult the upstream tool on how to set terminal width and match that in rich-codex. Fixing terminal width You can define a specific width to use for the terminal image using --terminal-width / $TERMINAL_WIDTH / terminal_width (CLI, env var, action/config). This is typically joined with --notrim to disable automatic trimming. If your console output doesn't match this width, you may get weird effects such as cropping or wrapping. You will probably want to try to match this width with upstream tools. Tip Some tools (such as rich-click ) also honour the environment variable $TERMINAL_WIDTH","title":"Terminal Width"},{"location":"config/width/#terminal-width","text":"","title":"Terminal Width"},{"location":"config/width/#trimming","text":"By default, rich-codex will run your command / parse your snippet and check the length of all output lines. The terminal width will be set to that of the longest line. A mimimum width is used to prevent very narrow images. The default for this is 80 characters and can be customised using --terminal-min-width / $TERMINAL_MIN_WIDTH / terminal_min_width (CLI, env var, action/config). To turn off trimming, use --notrim / $NOTRIM / notrim . Info Note that console output that is padded with spaces will use the full terminal width available. Much of the output from the rich library is padded. In these cases, you will need to consult the upstream tool on how to set terminal width and match that in rich-codex.","title":"Trimming"},{"location":"config/width/#fixing-terminal-width","text":"You can define a specific width to use for the terminal image using --terminal-width / $TERMINAL_WIDTH / terminal_width (CLI, env var, action/config). This is typically joined with --notrim to disable automatic trimming. If your console output doesn't match this width, you may get weird effects such as cropping or wrapping. You will probably want to try to match this width with upstream tools. Tip Some tools (such as rich-click ) also honour the environment variable $TERMINAL_WIDTH","title":"Fixing terminal width"},{"location":"inputs/config_file/","text":"YAML config files If you prefer, you can configure rich-codex outputs within YAML config files. Config file locations By default, rich-codex looks for files in the following locations (relative to where it runs): .rich-codex.yml .github/rich-codex.yml docs/img/rich-codex.yml You can pass one or more additional config locations (separated with newlines) using --configs / RC_CONFIGS / rc_configs (command line / environment variable / GitHub action key). Any files that are not found (including those supplied in addition to the defaults) will be silently ignored. Note Strange things may happen if you have more than one config file, such as global config settings overwriting one another in unpredictable ways. So it's probably best not to use more than one. Validation When found, rich-codex will first parse the YAML and validate using the bundled schema . If any validation errors are found, rich-codex will provide a log and exit with an error. Structure Config files can have both top-level configuration options that apply to all files and also an outputs array of different things to create. Each outputs array item must contain an img_paths array of output filenames and either a command or a snippet . You can optionally add title to customise the terminal window title. For example: outputs : - command : \"cat docs/cat.txt | lolcat -S 1\" title : Image from a config img_paths : - docs/img/cat.png - snippet : | #!/usr/bin/env python3 # -*- coding: utf-8 -*- from rich_codex.cli import main if __name__ == \"__main__\": main() img_paths : - docs/img/main_header.svg There are many other config keys also available. See the configuration docs for more details.","title":"Config file"},{"location":"inputs/config_file/#yaml-config-files","text":"If you prefer, you can configure rich-codex outputs within YAML config files.","title":"YAML config files"},{"location":"inputs/config_file/#config-file-locations","text":"By default, rich-codex looks for files in the following locations (relative to where it runs): .rich-codex.yml .github/rich-codex.yml docs/img/rich-codex.yml You can pass one or more additional config locations (separated with newlines) using --configs / RC_CONFIGS / rc_configs (command line / environment variable / GitHub action key). Any files that are not found (including those supplied in addition to the defaults) will be silently ignored. Note Strange things may happen if you have more than one config file, such as global config settings overwriting one another in unpredictable ways. So it's probably best not to use more than one.","title":"Config file locations"},{"location":"inputs/config_file/#validation","text":"When found, rich-codex will first parse the YAML and validate using the bundled schema . If any validation errors are found, rich-codex will provide a log and exit with an error.","title":"Validation"},{"location":"inputs/config_file/#structure","text":"Config files can have both top-level configuration options that apply to all files and also an outputs array of different things to create. Each outputs array item must contain an img_paths array of output filenames and either a command or a snippet . You can optionally add title to customise the terminal window title. For example: outputs : - command : \"cat docs/cat.txt | lolcat -S 1\" title : Image from a config img_paths : - docs/img/cat.png - snippet : | #!/usr/bin/env python3 # -*- coding: utf-8 -*- from rich_codex.cli import main if __name__ == \"__main__\": main() img_paths : - docs/img/main_header.svg There are many other config keys also available. See the configuration docs for more details.","title":"Structure"},{"location":"inputs/direct_inputs/","text":"Command-line / action inputs You can generate images by providing a command or snippet directly to the CLI at run time. You need the following command line flags / environment variables / GitHub Action inputs: One of: --command / $COMMAND / command --snippet / $SNIPPET / snippet And: --img-paths / $IMG_PATHS / img_paths For example: rich-codex --command 'my-command --yay' --img-paths 'docs/example.svg'","title":"Direct inputs"},{"location":"inputs/direct_inputs/#command-line-action-inputs","text":"You can generate images by providing a command or snippet directly to the CLI at run time. You need the following command line flags / environment variables / GitHub Action inputs: One of: --command / $COMMAND / command --snippet / $SNIPPET / snippet And: --img-paths / $IMG_PATHS / img_paths For example: rich-codex --command 'my-command --yay' --img-paths 'docs/example.svg'","title":"Command-line / action inputs"},{"location":"inputs/markdown/","text":"Running commands If you write markdown with images that contain just a backtick command as the alt-text, rich-codex will find them. For example, the following markdown will generate ../img/rich-codex-help.svg (the image shown above) based on the output of the command rich-codex --help : ![ `rich-codex --help` ]( ../img/rich-codex-help.svg ) Printing files Rich-codex bundles rich-cli for convenience, so you can easily produce screenshots of files with the rich command: Tip You probably want to hide the command with hide_command - see below for more about configuration. <!-- RICH-CODEX hide_command: true --> ![ `rich ../../src/rich_codex/rich_img.py --tail 20 --force-terminal` ]( ../img/rich-codex-snippet.svg ) Tip \ud83d\udca1 Use the --force-terminal flag to keep colours in your screenshots Title text You can also add markdown image title text in quotes after the filename, which will be used in the top menu bar of the screenshot terminal. (Alternatively, set the title config option in a comment). This can be useful when adding lots of command markup to get a good screenshot. You might also want to hide the command prompt. For example: You don't always want people to see the exact command you used, after all. <!-- RICH-CODEX hide_command: true --> ![ `rich ../../src/rich_codex/rich_img.py --tail 20 --force-terminal --guides --panel rounded --panel-style magenta --theme monokai` ]( ../img/rich-codex-snippet-title.svg \"rich_img.py\" ) Config comments You can use a HTML comment in a line above the image to set config attributes for this image only. The comment should begin with RICH-CODEX and then have valid YAML after that. The parsed configuration will be validated - see an overview of available variables on the config overview docs . For example: <!-- RICH-CODEX {terminal_width: 60, terminal_theme: MONOKAI} --> ![ `cowsay \"Taste the rainbow\" | lolcat -S 100` ]( ../img/taste-the-rainbow.svg \"Taste the rainbow\" ) Code snippets In addition to running commands, you can format code blocks or \"snippets\". To do this, make the <!-- RICH-CODEX code comment config with the snippet key. Remember that you can use the pipe character | in YAML to have multi-line strings, but you need to be careful with indentation to maintain valid YAML. I'd recommend you write the YAML in a code editor with syntax highlighting and then paste it in. Info The alt-text for the markdown image embed doesn't matter for snippets. However, if it has a command in backticks then this will take priority over the snippet. If the snippet is valid JSON, it will be pretty-printed and coloured. Otherwise text will default to white. <!-- RICH-CODEX snippet: | {\"menu\": { \"id\": \"file\", \"value\": \"File\", \"popup\": { \"menuitem\": [ {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"}, {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"}, {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"} ] } }} --> ![ my JSON snippet ]( ../img/example-json-snippet.svg ) For other code languages, use snippet_syntax to define which language to format in. For example: <!-- RICH-CODEX snippet_syntax: python snippet: | >>> print(\"[italic red]Hello[/italic red] World!\", locals()) Hello World! { ' __annotations__ ': {}, ' __builtins__ ': <module 'builtins' (built-in)>, ' __doc__ ': None, ' __loader__ ': <class ' _frozen_ importlib.BuiltinImporter'>, ' __name__ ': ' __main__ ', ' __package__ ': None, ' __spec__ ': None, 'print': <function print at 0x1027fd4c0>, } --> ![](../img/example-python-snippet.svg)","title":"Markdown"},{"location":"inputs/markdown/#running-commands","text":"If you write markdown with images that contain just a backtick command as the alt-text, rich-codex will find them. For example, the following markdown will generate ../img/rich-codex-help.svg (the image shown above) based on the output of the command rich-codex --help : ![ `rich-codex --help` ]( ../img/rich-codex-help.svg )","title":"Running commands"},{"location":"inputs/markdown/#printing-files","text":"Rich-codex bundles rich-cli for convenience, so you can easily produce screenshots of files with the rich command: Tip You probably want to hide the command with hide_command - see below for more about configuration. <!-- RICH-CODEX hide_command: true --> ![ `rich ../../src/rich_codex/rich_img.py --tail 20 --force-terminal` ]( ../img/rich-codex-snippet.svg ) Tip \ud83d\udca1 Use the --force-terminal flag to keep colours in your screenshots","title":"Printing files"},{"location":"inputs/markdown/#title-text","text":"You can also add markdown image title text in quotes after the filename, which will be used in the top menu bar of the screenshot terminal. (Alternatively, set the title config option in a comment). This can be useful when adding lots of command markup to get a good screenshot. You might also want to hide the command prompt. For example: You don't always want people to see the exact command you used, after all. <!-- RICH-CODEX hide_command: true --> ![ `rich ../../src/rich_codex/rich_img.py --tail 20 --force-terminal --guides --panel rounded --panel-style magenta --theme monokai` ]( ../img/rich-codex-snippet-title.svg \"rich_img.py\" )","title":"Title text"},{"location":"inputs/markdown/#config-comments","text":"You can use a HTML comment in a line above the image to set config attributes for this image only. The comment should begin with RICH-CODEX and then have valid YAML after that. The parsed configuration will be validated - see an overview of available variables on the config overview docs . For example: <!-- RICH-CODEX {terminal_width: 60, terminal_theme: MONOKAI} --> ![ `cowsay \"Taste the rainbow\" | lolcat -S 100` ]( ../img/taste-the-rainbow.svg \"Taste the rainbow\" )","title":"Config comments"},{"location":"inputs/markdown/#code-snippets","text":"In addition to running commands, you can format code blocks or \"snippets\". To do this, make the <!-- RICH-CODEX code comment config with the snippet key. Remember that you can use the pipe character | in YAML to have multi-line strings, but you need to be careful with indentation to maintain valid YAML. I'd recommend you write the YAML in a code editor with syntax highlighting and then paste it in. Info The alt-text for the markdown image embed doesn't matter for snippets. However, if it has a command in backticks then this will take priority over the snippet. If the snippet is valid JSON, it will be pretty-printed and coloured. Otherwise text will default to white. <!-- RICH-CODEX snippet: | {\"menu\": { \"id\": \"file\", \"value\": \"File\", \"popup\": { \"menuitem\": [ {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"}, {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"}, {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"} ] } }} --> ![ my JSON snippet ]( ../img/example-json-snippet.svg ) For other code languages, use snippet_syntax to define which language to format in. For example: <!-- RICH-CODEX snippet_syntax: python snippet: | >>> print(\"[italic red]Hello[/italic red] World!\", locals()) Hello World! { ' __annotations__ ': {}, ' __builtins__ ': <module 'builtins' (built-in)>, ' __doc__ ': None, ' __loader__ ': <class ' _frozen_ importlib.BuiltinImporter'>, ' __name__ ': ' __main__ ', ' __package__ ': None, ' __spec__ ': None, 'print': <function print at 0x1027fd4c0>, } --> ![](../img/example-python-snippet.svg)","title":"Code snippets"},{"location":"usage/cli/","text":"Command-line In addition to the GitHub Action, rich-codex is also a stand-alone command line tool. You are welcome to use it locally, for example when first writing new documentation and generating initial images to check their output. \ud83d\udca5\u26a0\ufe0f Warning \u26a0\ufe0f\ud83d\udca5 Please remember that rich-codex is designed to run arbitrary commands that it finds within documentation for your project. You alone are responsible for any damage you cause to your computer! \ud83d\ude43 Running rich-codex entirely within GitHub Actions is recommended \ud83d\udc4d\ud83c\udffb Local installation You can install rich-codex from the Python Package Index (PyPI) with pip or equivalent. pip install rich-codex At its simplest, the command-line tool runs without any arguments and recursively searches the current working directory for anything it recognises: rich-codex Behaviour can be customised with command-line flags or by setting environment variables, see rich-codex --help : Requirements for PNG / PDF outputs If you wish to generate PNG or PDF images (not just SVG ) then there are a few additional requirements. Conversion is done using CairoSVG . First, install rich-codex with the cairo extra : pip install rich-codex [ cairo ] You'll then probably need some additional libraries, see the Cairo documentation : CairoSVG and its dependencies may require additional tools during the installation: a compiler, Python headers, Cairo, and FFI headers. These tools have different names depending on the OS you are using, but: on Windows, you\u2019ll have to install Visual C++ compiler for Python and Cairo; on macOS, you\u2019ll have to install cairo and libffi (eg. with Homebrew : brew install cairo ); on Linux, you\u2019ll have to install the cairo, python3-dev and libffi-dev packages (names may vary for your distribution). Installation can be messy, so be prepared to do a bit of googling to get things to work. Remember that running rich-codex with the -v flag to get verbose logging can give you more information about what's going wrong (if anything). You'll also need Fira Code installed, an open-licence font: GitHub repo / Google Fonts .","title":"Command-line"},{"location":"usage/cli/#command-line","text":"In addition to the GitHub Action, rich-codex is also a stand-alone command line tool. You are welcome to use it locally, for example when first writing new documentation and generating initial images to check their output. \ud83d\udca5\u26a0\ufe0f Warning \u26a0\ufe0f\ud83d\udca5 Please remember that rich-codex is designed to run arbitrary commands that it finds within documentation for your project. You alone are responsible for any damage you cause to your computer! \ud83d\ude43 Running rich-codex entirely within GitHub Actions is recommended \ud83d\udc4d\ud83c\udffb","title":"Command-line"},{"location":"usage/cli/#local-installation","text":"You can install rich-codex from the Python Package Index (PyPI) with pip or equivalent. pip install rich-codex At its simplest, the command-line tool runs without any arguments and recursively searches the current working directory for anything it recognises: rich-codex Behaviour can be customised with command-line flags or by setting environment variables, see rich-codex --help :","title":"Local installation"},{"location":"usage/cli/#requirements-for-png-pdf-outputs","text":"If you wish to generate PNG or PDF images (not just SVG ) then there are a few additional requirements. Conversion is done using CairoSVG . First, install rich-codex with the cairo extra : pip install rich-codex [ cairo ] You'll then probably need some additional libraries, see the Cairo documentation : CairoSVG and its dependencies may require additional tools during the installation: a compiler, Python headers, Cairo, and FFI headers. These tools have different names depending on the OS you are using, but: on Windows, you\u2019ll have to install Visual C++ compiler for Python and Cairo; on macOS, you\u2019ll have to install cairo and libffi (eg. with Homebrew : brew install cairo ); on Linux, you\u2019ll have to install the cairo, python3-dev and libffi-dev packages (names may vary for your distribution). Installation can be messy, so be prepared to do a bit of googling to get things to work. Remember that running rich-codex with the -v flag to get verbose logging can give you more information about what's going wrong (if anything). You'll also need Fira Code installed, an open-licence font: GitHub repo / Google Fonts .","title":"Requirements for PNG / PDF outputs"},{"location":"usage/docker_image/","text":"There is a docker image for running rich-codex, available on GitHub : docker pull ghcr.io/ewels/rich-codex:latest The label latest will pull the most recent release The label main will pull the development version Releases will have their own specific labels. Warning If you're trying to run commands, they will likely not be available in the container! So this image is best used for code snippets or common linux tools. Alternatively, you can build your own docker image using this as a base, with additional dependencies installed: FROM ghcr.io/ewels/rich-codex:latest To run, a typical command would be: docker run -i -v ` pwd ` : ` pwd ` -w ` pwd ` -u $( id -u ) : $( id -g ) ghcr.io/ewels/rich-codex The -i flag enables stdin so that you can confirm running commands (alternatively, use --no-confirm at the end) The -v argument tells Docker to bind your current working directory ( pwd ) to the same path inside the container, so that files created there will be saved to your local file system outside of the container. -w sets the working directory in the container to this path, so that it's the same as your working directory outside of the container. -u sets your local user account as the user inside the container, so that any files created have the correct ownership permissions. You can then pass environment variables with the -e flag to customise behaviour. See the usage instructions below for the available environment variables.","title":"Docker image"},{"location":"usage/github_action/","text":"Rich-codex was primarily designed to run automatically with GitHub actions, to keep your screenshots up to date for you. If there are changes to the images, the action can exit with an error (default) or automatically commit the updates. Info For GitHub Actions to push commits to your repository, you'll need to set Workflow permissions to Read and write permissions under Actions -> General in the repo settings. See the GitHub docs . Example workflow This action looks for rich-codex content in the repo. It removes any SVG files found in docs/img/ that don't match the outputs and generates the updated images. If there have been any changes, it pushes a new commit with the updated images. .github/workflows/screenshots.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 name : Rich-codex on : [ push ] jobs : rich_codex : runs-on : ubuntu-latest steps : - name : Check out the repo uses : actions/checkout@v3 - name : Install your custom tools run : pip install . - name : Generate terminal images with rich-codex uses : ewels/rich-codex@v1 with : commit_changes : \"true\" clean_img_paths : docs/img/*.svg For a more complex example, see .github/workflows/examples.yml in this repository. Triggers In the above example, the workflow is triggered by the line on: [push] . This means that new screenshots will be generated on every commit. For some people this may be a little excessive, in which case you might prefer some of the following suggestions. Warning If you have commit_changes: \"true\" set as in the example above, you should only run in environments where pushing a new commit is possible. For example, using this in a workflow triggered by a release will fail because the workflow will be running on a detached commit. Note that GitHub has extensive documentation on the different ways to trigger actions workflows. Tip You can mix and match multiple different triggers! If specific files are edited If you only want to re-render screenshots if certain files (or filetypes) are edited, you can filter the push event with the paths key : on : push : paths : - \"**.md\" - .rich-codex.yml - src/myapp/cli-flags.py Specific branches You can run on pushes to the main and staging branches only by using: on : push : - main - staging Manually running You can manually run the workflow by pressing a button in the GitHub website . Just use: on : workflow_dispatch Filtering for commit message You can filter by commit message by always running on every push, but then using an if statement on the job. For example, we can take the main example above and add the following to only run when the commit message includes the string [screenshots] : .github/workflows/screenshots.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 name : Rich-codex on : [ push ] jobs : rich_codex : if : \"contains(github.event.head_commit.message, '[screenshots]')\" runs-on : ubuntu-latest steps : - name : Check out the repo uses : actions/checkout@v3 - name : Install your custom tools run : pip install . - name : Generate terminal images with rich-codex uses : ewels/rich-codex@v1 with : commit_changes : \"true\" clean_img_paths : docs/img/*.svg GitHub Action Inputs Basically everything that you can configure via the command line interface / config can also be configured within GitHub actions via the with key. For a full description of all available inputs, please see the configuration overview docs .","title":"GitHub Action"},{"location":"usage/github_action/#example-workflow","text":"This action looks for rich-codex content in the repo. It removes any SVG files found in docs/img/ that don't match the outputs and generates the updated images. If there have been any changes, it pushes a new commit with the updated images. .github/workflows/screenshots.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 name : Rich-codex on : [ push ] jobs : rich_codex : runs-on : ubuntu-latest steps : - name : Check out the repo uses : actions/checkout@v3 - name : Install your custom tools run : pip install . - name : Generate terminal images with rich-codex uses : ewels/rich-codex@v1 with : commit_changes : \"true\" clean_img_paths : docs/img/*.svg For a more complex example, see .github/workflows/examples.yml in this repository.","title":"Example workflow"},{"location":"usage/github_action/#triggers","text":"In the above example, the workflow is triggered by the line on: [push] . This means that new screenshots will be generated on every commit. For some people this may be a little excessive, in which case you might prefer some of the following suggestions. Warning If you have commit_changes: \"true\" set as in the example above, you should only run in environments where pushing a new commit is possible. For example, using this in a workflow triggered by a release will fail because the workflow will be running on a detached commit. Note that GitHub has extensive documentation on the different ways to trigger actions workflows. Tip You can mix and match multiple different triggers!","title":"Triggers"},{"location":"usage/github_action/#if-specific-files-are-edited","text":"If you only want to re-render screenshots if certain files (or filetypes) are edited, you can filter the push event with the paths key : on : push : paths : - \"**.md\" - .rich-codex.yml - src/myapp/cli-flags.py","title":"If specific files are edited"},{"location":"usage/github_action/#specific-branches","text":"You can run on pushes to the main and staging branches only by using: on : push : - main - staging","title":"Specific branches"},{"location":"usage/github_action/#manually-running","text":"You can manually run the workflow by pressing a button in the GitHub website . Just use: on : workflow_dispatch","title":"Manually running"},{"location":"usage/github_action/#filtering-for-commit-message","text":"You can filter by commit message by always running on every push, but then using an if statement on the job. For example, we can take the main example above and add the following to only run when the commit message includes the string [screenshots] : .github/workflows/screenshots.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 name : Rich-codex on : [ push ] jobs : rich_codex : if : \"contains(github.event.head_commit.message, '[screenshots]')\" runs-on : ubuntu-latest steps : - name : Check out the repo uses : actions/checkout@v3 - name : Install your custom tools run : pip install . - name : Generate terminal images with rich-codex uses : ewels/rich-codex@v1 with : commit_changes : \"true\" clean_img_paths : docs/img/*.svg","title":"Filtering for commit message"},{"location":"usage/github_action/#github-action-inputs","text":"Basically everything that you can configure via the command line interface / config can also be configured within GitHub actions via the with key. For a full description of all available inputs, please see the configuration overview docs .","title":"GitHub Action Inputs"}]}